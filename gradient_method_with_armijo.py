import numpy as np
import matplotlib.pyplot as plt


def gradient_method_armijo_rule(A, b, x0, epsilon, gamma, beta):
    '''
    Modified gradient method with Armiho rule to find the step size.
    For functions of the form f(x) = x^T A x + 2*b^T x, where A is a positive definite matrix and b is a vector
    
    A - positive definite matrix associated with the objective function
    b - vector associated with the linear part objective function
    x0 - initial point
    epsilon - tolerance

    S0 - initial step size = 1
    gamma - parameter in Armijo rule to check validity of step size in (0,1) 
    beta - parameter in Armijo rule to change step size in (0,1) gives set of step sizes {1, beta, beta^2, ...}

    x - optimal solution
    k - number of iterations
    xk - sequence of points generated by the gradient method
    '''

    # Initialization
    xk = [x0]
    x = x0
    k = 0
    S0 = 1
    fun_value = x.T @ A @ x + 2 * b.T @ x
    grad = 2 * A @ x + 2 * b
    grad_norm = np.linalg.norm(grad)
    while grad_norm > epsilon:
        k += 1
        t=S0
        # Armijo rule 
        # Set of step sizes {1, beta, beta^2, ...} until the validity condition is satisfied
        x_iter = x - t * grad
        fun_value_iter = x_iter.T @ A @ x_iter + 2 * b.T @ x_iter
        while fun_value - fun_value_iter < gamma * t * grad_norm**2:
            t = beta * t
            x_iter = x - t * grad
            fun_value_iter = x_iter.T @ A @ x_iter + 2 * b.T @ x_iter
        x = x_iter
        xk.append(x)
        fun_value = fun_value_iter
        grad = 2 * A @ x + 2 * b
        grad_norm = np.linalg.norm(grad)
    return x, k, xk

# plot the quadratic function
A = np.array([[1, 0], [0, 2]])
b = np.array([0, 0])
x0 = np.array([2, 1])
epsilon = 1e-5
gamma = 0.25
beta = 0.5

x, k, xk = gradient_method_armijo_rule(A, b, x0, epsilon, gamma, beta)
print('The optimal solution is', int(x[0]), int(x[1]))
print('The number of iterations is', k)

# plot the quadratic function
x = np.linspace(-2, 2, 100)
y = np.linspace(-2, 2, 100)
X, Y = np.meshgrid(x, y)
F = X**2 + 2*Y**2
plt.contour(X, Y, F, 20)

# plot the sequence of points generated by the gradient method
xk = np.array(xk)
plt.plot(xk[:, 0], xk[:, 1], 'ro-')
plt.show()

